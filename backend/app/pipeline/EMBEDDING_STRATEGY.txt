=================================================================
FLOWSIGHT AI - HYBRID EMBEDDING STRATEGY
=================================================================

OVERVIEW
--------
Hybrid BM25 + Semantic search combining:
- Dense embeddings (watsonx.ai) for semantic understanding
- Sparse embeddings (BM25) for keyword matching
- Best of both worlds for workflow intelligence

=================================================================
ARCHITECTURE
=================================================================

1. DUAL EMBEDDING APPROACH (Option C - Hybrid)

   Event-Level Embeddings:
   - Each event embedded individually
   - Fine-grained semantic search
   - Example: "authentication commit" matches auth-related commits

   Contextual Embeddings:
   - Events embedded with surrounding context
   - Rich understanding of relationships
   - Example: PR with all commit messages embedded together

2. DENSE EMBEDDINGS (Semantic Search)

   Model: IBM watsonx.ai - slate-125m-english-rtrvr
   Dimension: 768
   Metric: Cosine similarity

   What gets embedded:
   ✓ Commit messages
   ✓ PR titles + descriptions + commit context
   ✓ CI workflow names + status
   ✓ Deployment environment + status

   Use cases:
   - "Find PRs related to authentication" (semantic match)
   - "Similar bottlenecks to current issue" (pattern matching)
   - "Recommend reviewers based on expertise" (similarity)

3. SPARSE EMBEDDINGS (Keyword Search)

   Method: BM25 (TF-IDF variant)

   What gets indexed:
   ✓ Raw text from all events
   ✓ Contextual descriptions

   Use cases:
   - "Find commits with 'API-123'" (exact match)
   - "PRs mentioning 'security'" (keyword)
   - "CI runs with 'timeout' error" (literal search)

4. HYBRID SEARCH

   Combines both approaches:
   - Dense vector similarity score
   - BM25 keyword relevance score
   - Weighted fusion (alpha parameter)

   Benefits:
   ✓ Semantic understanding + exact matching
   ✓ Handles both "similar concepts" and "exact terms"
   ✓ Production-grade retrieval quality

=================================================================
DATA STRUCTURE
=================================================================

Each event in Astra DB contains:

{
  "_id": "repo/event-id",
  "type": "commit|pull_request|workflow_run|deployment",
  "source": "github",

  // Original data
  "sha": "abc123...",
  "message": "feat: add auth",
  "author": "username",

  // Text prepared for search
  "event_text": "feat: add auth",
  "contextual_text": "Commit by username: feat: add auth",
  "text_for_bm25": "Commit by username: feat: add auth",

  // Dense embeddings (768-dim vectors)
  "event_embedding": [0.123, -0.456, ...],      // Individual
  "contextual_embedding": [0.789, 0.234, ...],  // With context

  // Metadata
  "timestamp": "2025-01-30T...",
  "repo_id": "owner/repo"
}

=================================================================
ASTRA DB CONFIGURATION
=================================================================

Collection: workflow_events

Vector Configuration:
- Dimension: 768
- Metric: cosine
- Indexing: All fields (for BM25)

Supports:
✓ Vector similarity search
✓ Text/BM25 search
✓ Hybrid queries
✓ Filtering by metadata

=================================================================
USAGE EXAMPLES
=================================================================

1. EXTRACT + EMBED + UPLOAD (Full Pipeline)

   python app/pipeline/run_pipeline.py owner/repo \
     --generate-embeddings \
     --upload-to-astra

   This will:
   1. Extract GitHub data
   2. Generate dense embeddings via watsonx.ai
   3. Prepare BM25 text fields
   4. Upload to Astra DB with vector indexes

2. JUST EXTRACT + EMBED (No Upload)

   python app/pipeline/run_pipeline.py owner/repo \
     --generate-embeddings

   Saves: data/github_cleaned_<repo>.json
   Contains: All data + embeddings

3. SEMANTIC SEARCH (In Astra DB)

   collection.vector_find(
       query_embedding,
       limit=10,
       include_similarity=True
   )

4. KEYWORD SEARCH (BM25)

   collection.find(
       {"$text": {"$search": "authentication"}},
       limit=10
   )

5. HYBRID SEARCH

   hybrid_search(
       collection,
       query_text="authentication security",
       query_embedding=embed("authentication security"),
       alpha=0.5  # 50% semantic, 50% keyword
   )

=================================================================
AI AGENT USE CASES
=================================================================

1. BOTTLENECK DETECTION AGENT
   - Search: "PRs waiting >48 hours for review"
   - Uses: Keyword search for status + semantic for patterns

2. WORKFLOW ANALYSIS AGENT
   - Search: "Find similar workflow patterns"
   - Uses: Dense embeddings to find analogous workflows

3. RECOMMENDATION AGENT
   - Search: "Who reviewed similar PRs?"
   - Uses: Contextual embeddings to match expertise

4. ISSUE CORRELATION AGENT
   - Search: "Related issues across projects"
   - Uses: Hybrid search for both exact + semantic matches

=================================================================
PERFORMANCE CHARACTERISTICS
=================================================================

Dense Search (Vector):
- Latency: ~10-50ms
- Recall: High for semantic queries
- Use: Conceptual matching

Sparse Search (BM25):
- Latency: ~5-20ms
- Precision: High for exact terms
- Use: Literal matching

Hybrid Search:
- Latency: ~20-100ms (both searches)
- Quality: Best overall retrieval
- Use: Production queries

=================================================================
REQUIRED CREDENTIALS
=================================================================

.env file:

# GitHub
GITHUB_TOKEN=ghp_...

# Astra DB
ASTRA_DB_TOKEN=AstraCS:...
ASTRA_DB_ENDPOINT=https://...-region.apps.astra.datastax.com

# watsonx.ai (for embeddings)
WATSONX_API_KEY=your_api_key
WATSONX_PROJECT_ID=your_project_id
WATSONX_URL=https://us-south.ml.cloud.ibm.com

=================================================================
COMPLETE PIPELINE FLOW
=================================================================

GitHub API
    ↓
Extract (github_extractor.py)
    ↓
Clean & Format
    ↓
Generate Embeddings (embedding_strategy.py)
    ├─→ Event-level embeddings
    └─→ Contextual embeddings
    ↓
Prepare BM25 Text
    ↓
Upload to Astra DB (astra_uploader.py)
    ├─→ Store documents
    ├─→ Create vector indexes
    └─→ Enable BM25 search
    ↓
Ready for watsonx AI Agents
    ├─→ Semantic search
    ├─→ Keyword search
    └─→ Hybrid queries

=================================================================
END OF EMBEDDING STRATEGY
=================================================================
